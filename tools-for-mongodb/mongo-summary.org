* Introduction
mongo-summary attempts to provide a similar behavior to pt-mysql-summary but for mongodb/tokumx servers. 

I decided to write this in Javascript, since that lets me make use of the mongodb shell and not have any external dependencies at all. For example, I did some basic tests with python and PyMongo early on, but this means the target system must have PyMongo installed, and it can't have a bson package installed, as PyMongo provides its own (and AFAIK incompatible) one. 

I am not a Javascript programmer so a lot of the code probably will feel odd or even ugly to seasoned Javascript programmers.  

* Generating the utility
I used emacs and org-mode to write this, so if you want to change the org file and generate the resulting files again, you'll need to extract source code from the org file. This is done via the org-babel-tangle function, which by default is bound to C-c C-v t. You can find more information about this process [[http://orgmode.org/manual/Extracting-source-code.html][here]].
* Usage
Tangling will generate two files: 
- mongo-summary.js
- mongo-summary.sh

The second one is a basic wrapper to invoke mongo with the script as an argument.
As it is currently just a test, it must be invoked from the same dir as where the js file lives. 
You should invoke the script with any arguments you'd pass to mongo, i.e.: 

#+BEGIN_EXAMPLE
./mongo-summary.sh --port 29000
#+END_EXAMPLE

Remember to chmod +x mongo-summary.sh as org-mode won't do that when tangling. 

* The code 
This section contains the source code for mongo-summary. I tend to work in a bottom-up approach and so that's the order in which I explain my ideas. 
** Utility functions and global variables 
This section contains utility functions that will be used by the rest of the code, and global variables used by all functions. 

pt-mysql-summary produces header lines such as this one: 
#+BEGIN_EXAMPLE
# Percona Toolkit MySQL Summary Report #######################
#+END_EXAMPLE
so I need a function to generate similar lines. 

#+NAME: getHeader
#+BEGIN_SRC js
  function getHeader(header, filler, length) {
      var result = "\n# " + header + " ";
      if (result.length < length) {
          for (i=result.length; i<length; i++) {
              result += filler
          }
      }
      return result + "\n";
  }
#+END_SRC

This function can be used like so: 
#+BEGIN_SRC js
  print(getHeader("Percona Toolkit MongoDB Summary Report","#",62))
#+END_SRC

Length will always be the same and is specified by the following variable: 
#+NAME: length
#+BEGIN_SRC js
var LENGTH = 62;
#+END_SRC

Filler will also be the same all the time: 
#+NAME: filler 
#+BEGIN_SRC js
var FILLER = "#";
#+END_SRC

I don't know if this is already available on javascript, but I need a function to print a number and, if needed, prefix it with a 0. 
#+HEADERS: :tangle mongo-summary.js
#+BEGIN_SRC js
  function getFilledDatePart(datepart) {
      return datepart < 10 ? "0" + datepart : datepart;
  }
#+END_SRC

I also need a function to determine if I'm connected to mongos or mongod. For now, I think running isMaster and looking for "msg" seems reliable, though I have not find it documented yet. 
#+NAME: isMongos 
#+BEGIN_SRC js
  function isMongos() {
      return db.runCommand({isMaster: 1})["msg"] == "isdbgrid";
  }
#+END_SRC

Now, let's write these functions to both scripts
#+HEADERS: :tangle mongo-summary.js :noweb yes
#+BEGIN_SRC js
<<getHeader>>
<<length>>
<<filler>>
<<isMongos>>
#+END_SRC

#+HEADERS: :tangle mongo-summary-extra.js :noweb yes
#+BEGIN_SRC js
<<getHeader>>
<<length>>
<<filler>>
<<isMongos>>
#+END_SRC

** mongod info functions
This section contains functions used to obtain information about a mongodb/tokumx instance, while connected to it via mongo. Functions to obtain information while connected to mongos are included in the next section. 

Let's start with a function to get the current date from [[http://docs.mongodb.org/manual/reference/method/db.hostInfo/#db.hostInfo][hostInfo]], and some basic info about operations in progress. 
#+HEADERS: :tangle mongo-summary.js
#+BEGIN_SRC js
  function getInstanceBasicInfo(db) {
      var result = {};
      var aux;
      aux = db.hostInfo()["system"]["currentTime"];
      result["serverTime"] = aux.getFullYear() + "-" + getFilledDatePart(aux.getMonth()) + "-" + getFilledDatePart(aux.getDay()) + " " + aux.toTimeString();
      aux = db.currentOp()["inprog"];
      result["inprog"] = aux.length + " operations in progress";
      result["hostname"] = db.hostInfo()["system"]["hostname"];
      return result;
  }
#+END_SRC

Now get some info about replication. We want to know if we're a standalone instance (which should only happen in dev/testing) or part of a replica set.  
#+HEADERS: :tangle mongo-summary.js
#+BEGIN_SRC js
  function getReplicationSummary(db) {
      var result = {};
      var rstatus = db._adminCommand("replSetGetStatus");
      result["ok"] = rstatus["ok"];
      if (rstatus["ok"]==0) {
          // This is either not a replica set, or there is an error
          if (rstatus["errmsg"] == "not running with --replSet") {
             result["summary"] = "Standalone mongod" 
          } else {
              result["summary"] = "Replication error: " + rstatus["errmsg"]
          }
      } else {
          // This is a replica set
          var secondaries = 0;
          var arbiters = 0;
          result["members"] = [];
          rstatus["members"].forEach(
              function (element, index, array) {
                  if (element["self"]) {
                      result["summary"] = "Node is " + element["stateStr"] + " in a " + rstatus["members"].length + " members replica set"
                  } else {
                      if (element["state"] == 2) {
                          secondaries++;
                      } else if (element["state"] == 7) {
                          arbiters++;
                      }
                  }
                  result["members"].push(element["name"]);
              }
          )
          result["summaryExtra"] = "The set has " + secondaries + " secondaries and " + arbiters + " arbiters";
      }
      return result;
  } 
#+END_SRC 

** mongos info functions
This section contains functions used to obtain sharding information and can only be used while connected to mongodb/tokumx via mongos.  
Let's start with getting a list of shard nodes and sharded collections.
We can get this info from sh.status(): 

#+HEADERS: :tangle mongo-summary.js
#+BEGIN_SRC js
  function getShardingSummary() {
      var result = {};
      result["shards"] = [];
      result["shardedDatabases"] = [];
      result["unshardedDatabases"] = [];
      var con = db.getMongo().getDB("config");
      con.databases.find().forEach(
          function (element, index, array) {
              if (element["partitioned"]) {
                  result["shardedDatabases"].push(element);
              } else {
                  result["unshardedDatabases"].push(element);
              }
          }
      );
      con.shards.find().forEach (
          function (element, index, array) {
              result["shards"].push({_id: element["_id"], host: element["host"].slice(element["host"].indexOf("/")+1,element["host"].length)});
          }
      );
      return result;
  }
#+END_SRC

Now we need to use getShardingSummary() to get a list of shards, and connect to each shard to run the mongod info functions. 

#+HEADERS: :tangle mongo-summary.js
#+BEGIN_SRC js
  function getShardsInfo() {
      var shardingSummary = getShardingSummary();
      var result = {};
      result["shards"] = [];
      shardingSummary["shards"].forEach(
          function (element, index, array) {
              //var db = connect(element["host"] + "/local");
              var db = new Mongo(element["host"]).getDB("local")
              result["shards"].push({
                  _id: element["_id"],
                  host: element["host"],
                  hostInfo: getInstanceBasicInfo(db),
                  replicationSummary: getReplicationSummary(db)
              })
          }
      );
      return result;
  }
#+END_SRC

** gathering additional information 
Besides the summarized information, we want to gather raw data (json output from mongod and plain text from log and config files) and optionally include it in the report for review. 

Because we want this to be optionally included, it will get sent to a separate js file. 

#+HEADERS: :tangle mongo-summary-extra.js
#+BEGIN_SRC js
  function printExtraDiagnosticsInfo() {
      print(getHeader("Extra info",FILLER,LENGTH));
#+END_SRC

Let's start with getting a list of databases and their collections: 
#+HEADERS: :tangle mongo-summary-extra.js
#+BEGIN_SRC js
      db.adminCommand('listDatabases')["databases"].forEach(
          function (element, array, index) {
              var auxdb = db.getSiblingDB(element["name"]);
              var cols = auxdb.getCollectionNames();
              print(element["name"] + " has " + cols.length + " collections and " + element["sizeOnDisk"] + " bytes on disk");
              if (cols.length > 0) {
                  print("Collections: ");
                  cols.forEach(
                      function (element, array, index) {
                          print("   " + element);
                      }
                  );
              }
          }
      );
#+END_SRC

Now print some raw json (some of which we've summarized already) depending on the node type we're on
#+HEADERS: :tangle mongo-summary-extra.js
#+BEGIN_SRC js
      if (isMongos()) {
          sh.status();
      } else {
          printjson(db.adminCommand('replSetGetStatus')); 
      }
      db.isMaster();
      print(getHeader("Logs",FILLER,LENGTH));
      db.adminCommand({'getLog': '*'})["names"].forEach(
          function (element, array, index) {
              db.adminCommand({'getLog': element})["log"].forEach(
                  function (element, array, index) {
                      print(element);
                  }
              );
          }
      );
  }
#+END_SRC

** Presentation 
   
Now it's time to put it all together and print the report. 
This is not a function, because it is what will be run by the mongo shell when it is invoked with this js file as argument. 

#+HEADERS: :tangle mongo-summary.js
#+BEGIN_SRC js
  print(getHeader("Percona Toolkit MongoDB Summary Report",FILLER,LENGTH));
  var aux = getInstanceBasicInfo(db);
  print("Report generated on " + aux["hostname"] + " at " + aux["serverTime"]);
  print(aux["inprog"]);
  if (isMongos()) {
      print(getHeader("Sharding Summary (mongos detected)",FILLER,LENGTH));
      aux = getShardingSummary();
      print("Detected " + aux["shards"].length + " shards");
      print("Sharded databases: ");
      aux["shardedDatabases"].forEach(function (element, array, index) {print("  " + element["_id"]);});
      print("");
      print("Unsharded databases: ");
      aux["unshardedDatabases"].forEach(function (element, array, index) {print("  " + element["_id"]);});
      print("");
      print(getHeader("Shards detail",FILLER,LENGTH));
      getShardsInfo()["shards"].forEach(
          function (element, array, index) {
              print("Shard " + element["_id"] + " @ " + element["host"]);
              print("(" + element["hostInfo"]["inprog"] + ")");
              print(element["replicationSummary"]["summary"]);
              print(element["replicationSummary"]["summaryExtra"]);
              print("");
          }
      );
  } else { 
      print(getHeader("Replication summary",FILLER,LENGTH));
      aux = getReplicationSummary(db);
      print(aux["summary"]);
      print(aux["summaryExtra"]);
      if (aux["members"].length > 0) {
          print(getHeader("Replica set members",FILLER,LENGTH));
          aux["members"].forEach(
              function(member, array, index) {
                  print(member);
              }
          );
      }
  } 
#+END_SRC

We also need presentation code for the extra script. 

#+HEADERS: :tangle mongo-summary-extra.js
#+BEGIN_SRC js
printExtraDiagnosticsInfo();
#+END_SRC

And finally, create a shell script that can invoke the js with the right arguments
#+HEADERS: :tangle mongo-summary.sh
#+BEGIN_SRC sh
    extra=0
    [ "$1" == "--extra" ] && {
        extra=1
        shift
    }
    mongo mongo-summary.js $*
    [ $extra -eq 1 ] && mongo mongo-summary-extra.js $*
#+END_SRC
