package main

/*
Just read lines from input while available and transform them to csv lines
Meant to be used with the *-processlist captures generated by pt-stalk.
This specific file is a one-off hack for captures taken on 5.1 but it should not be difficult to generalize

Companion files:
- load_data.r : R commands to plot thread's Command value over time for all captures (groups by timestamp)
- sample_plot.png : A sample plot generated with load_data.r

*/

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

const (
	ts_pattern      = `^TS [0-9][0-9]*`
	row_sep_pattern = `.*[0-9]\. row \*\*\*\*\*`
)

// maps are not valid constants hence I need the section below
var (
	// The reason I use a map below is because I could not find a Set like structure, and I don't want to iterate over an array all the time to see if the field name I got is a valid field. These are not just valid fields. This are fields that are both valid and that I want to feed into R (i.e. I don't care for 'Info' here since I won't be handling query text from R)
	valid_fields = map[string]bool{"User": true, "Host": true, "db": true, "Command": true, "Time": true, "State": true, "Rows_sent": true, "Rows_examined": true, "Rows_read": true}
	// The purpose of the map below is to store the last output column depending on mysql version. This one is hardcoded for 5.1 but eventually the version should be an argument
	last_field = map[string]string{"5.1": "Rows_read"}
)

/*
read from stdin until EOF
when a line that matches ts_pattern is seen, go into 'read sample' mode
while in 'read sample' mode, when a line that matches row_sep_pattern is seen, go into 'read row' mode
while in 'read row' mode, when a line that matches row_sep_pattern is seen, then print out the row, and go back into 'read row' mode
but if a line that matches ts_pattern is seen, go back into 'read sample' mode
also, while in read row mode, if this is the first row I am reading, print the csv header
*/
func main() {
	in := bufio.NewScanner(os.Stdin)
	tsMatcher := regexp.MustCompile(ts_pattern)
	rowSepMatcher := regexp.MustCompile(row_sep_pattern)
	firstRow := true
	sample := 0
	for in.Scan() { // read stdin until EOF
		if tsMatcher.MatchString(in.Text()) { // enter 'read sample' mode
			sample += 1
			for in.Scan() {
				if rowSepMatcher.MatchString(in.Text()) { // enter 'read row' mode
					csvheader := "sample," // constructing this for every row will have a cost but I do not care about it now
					row := strconv.Itoa(sample) + ","
					if tsMatcher.MatchString(in.Text()) {
						sample += 1
					}
					for in.Scan() {
						if tsMatcher.MatchString(in.Text()) {
							sample += 1
						}
						gotData := false
						line := strings.Split(in.Text(), ":")
						if len(line) > 1 {
							fname := strings.Trim(line[0], " ")
							if valid_fields[fname] {
								csvheader += fname
								row += strings.Replace(strings.Trim(line[1], " "), "'", `\'`, -1)
								if last_field["5.1"] != fname { // this is the part that is currently hardcoded
									gotData = true //this part that will have to be changed depending on the mysql verion. Not too difficult. Just a map string[string] with terminating_field per version
								}
							}
						}
						if rowSepMatcher.MatchString(in.Text()) {
							if firstRow {
								fmt.Println(csvheader)
								firstRow = false
							}
							fmt.Println(row)
							break
						} else if gotData {
							csvheader += ","
							row += ","
						}
					}
				}
			}
		}

	}
}
