package main

/*
Just read lines from input while available and transform them in 'insert into ...' statements.
Meant to be used with the *-processlist captures generated by pt-stalk.
This specific file is a one-off hack for captures taken on 5.1 but it should not be difficult to generalize

create table for the specific example I wrote this for:

create table processlist_captures (
	pk int unsigned not null auto_increment primary key,
	Id char(40),
	ts char(44),
	User char(40),
    Host char(80),
	db char(80),
	Command char(40),
	Time char(40),
	State char(80),
	Info tinytext,
	Rows_sent char(10),
	Rows_examined char(10),
	Rows_read char(10)
) engine = innodb;

table structure is awful but it will always be small, and the only goal is to feed R with it. hence everythig is a text field


Companion files:
- load_data.r : R commands to plot thread's Command value over time for all captures (groups by timestamp)
- sample_plot.png : A sample plot generated with load_data.r 
*/

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

const (
	ts_pattern      = `^TS [0-9][0-9]*`
	row_sep_pattern = `.*[0-9]\. row \*\*\*\*\*`
	table_name      = "processlist_captures" // TODO: make this a default but allow to change via option
)

// maps are not valid constants hence I need the section below
var (
	// The reason I use a map below is because I could not find a Set like structure, and I don't want to iterate over an array all the time to see if the field name I got is a valid field
	valid_fields = map[string]bool{"Id": true, "User": true, "Host": true, "db": true, "Command": true, "Time": true, "State": true, "Info": true, "Rows_sent": true, "Rows_examined": true, "Rows_read": true}
	// The purpose of the map below is to store the last output column depending on mysql version. This one is hardcoded for 5.1 but eventually the version should be an argument
	last_field = map[string]string{"5.1": "Rows_read"}
)

/*
read from stdin until EOF
when a line that matches ts_pattern is seen, go into 'read sample' mode
while in 'read sample' mode, when a line that matches row_sep_pattern is seen, go into 'read row' mode
while in 'read row' mode, when a line that matches row_sep_pattern is seen, then print out the row, and go back into 'read row' mode
but if a line that matches ts_pattern is seen, go back into 'read sample' mode
*/
func main() {
	in := bufio.NewScanner(os.Stdin)
	tsMatcher := regexp.MustCompile(ts_pattern)
	rowSepMatcher := regexp.MustCompile(row_sep_pattern)
	for in.Scan() { // read stdin until EOF
		if tsMatcher.MatchString(in.Text()) { // enter 'read sample' mode
			ts := in.Text()
			for in.Scan() {
				if rowSepMatcher.MatchString(in.Text()) { // enter 'read row' mode
					fmt.Print("insert into ", table_name, " set pk=null, ts = '", ts, "', ")
					for in.Scan() {
						gotData := false
						// right now this next line means I will break the Info: line. It will be mostly useless.
						// I do not care at this moment. I think long run I will only want to have
						// things I can measure + graph and not the query text, back into the database
						line := strings.Split(in.Text(), ":")
						if len(line) > 1 {
							fname := strings.Trim(line[0], " ")
							if valid_fields[fname] {
								fmt.Print("", fname, " = '", strings.Replace(strings.Trim(line[1], " "), "'", `\'`, -1), "'")
								if last_field["5.1"] != fname { // this is the part that is currently hardcoded
									gotData = true //this part that will have to be changed depending on the mysql verion. Not too difficult. Just a map string[string] with terminating_field per version
								}
							}
						}
						if rowSepMatcher.MatchString(in.Text()) {
							fmt.Println(";")
							break
						} else if gotData {
							fmt.Print(", ")
						}
					}
				}
			}
		}
	}
}
