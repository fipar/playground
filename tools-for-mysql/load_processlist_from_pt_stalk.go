package main

/*
Just read lines from input while available and transform them in 'insert into ...' statements.
Meant to be used with the *-processlist captures generated by pt-stalk.
This specific file is a one-off hack for captures taken on 5.1 but it should not be difficult to generalize

create table for the specific example I wrote this for:

create table processlist_captures (
	id int unsigned not null auto_increment primary key,
	ts char(44),
	User char(40),
    Host char(80),
	dn char(80),
	Command char(40),
	Time char(40),
	State char(80),
	Info tinytext,
	Rows_sent char(10),
	Rows_examined char(10),
	Rows_read char(10)
) engine = innodb;

table structure is awful but it will always be small, and the only goal is to feed R with it. hence everythig is a text field

*/

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

const (
	ts_pattern      = `^TS [0-9][0-9]*`
	row_sep_pattern = `.*[0-9]\. row \*\*\*\*\*`
	table_name      = "processlist_captures" // TODO: make this a default but allow to change via option
)

/*
read from stdin until EOF
when a line that matches ts_pattern is seen, go into 'read sample' mode
while in 'read sample' mode, when a line that matches row_sep_pattern is seen, go into 'read row' mode
while in 'read row' mode, when a line that matches row_sep_pattern is seen, then print out the row, and go back into 'read row' mode
but if a line that matches ts_pattern is seen, go back into 'read sample' mode
*/
func main() {
	in := bufio.NewScanner(os.Stdin)
	tsMatcher := regexp.MustCompile(ts_pattern)
	rowSepMatcher := regexp.MustCompile(row_sep_pattern)
	for in.Scan() { // read stdin until EOF
		if tsMatcher.MatchString(in.Text()) { // enter 'read sample' mode
			ts := in.Text()
			for in.Scan() {
				if rowSepMatcher.MatchString(in.Text()) { // enter 'read row' mode
					fmt.Print("insert into ", table_name, " set ts = '", ts, "', ")
					for in.Scan() {
						gotData := false
						// right now this next line means I will break the Info: line. It will be mostly useless.
						// I do not care at this moment. I think long run I will only want to have
						// things I can measure + graph and not the query text, back into the database
						line := strings.Split(in.Text(), ":")
						if len(line) > 1 {
							fmt.Print("", strings.Trim(line[0], " "), " = '", strings.Trim(line[1], " "), "'")
							if strings.Trim(line[0], " ") != "Rows_read" {
								gotData = true //this is the part that will have to be changed depending on the mysql verion. Not too difficult. Just a map string[string] with terminating_field per version
							}
						}
						if rowSepMatcher.MatchString(in.Text()) {
							fmt.Println(");")
							break
						} else if gotData {
							fmt.Print(", ")
						}
					}
				}
			}
		}
	}
}
